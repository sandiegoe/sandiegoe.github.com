{"meta":{"title":"Arexstorm个人工作站","subtitle":"","description":"","author":"Arexstorm","url":"http://sandiegoe.github.io","root":"/"},"pages":[],"posts":[{"title":"Redis数据类型","slug":"Redis数据类型","date":"2022-05-15T13:37:12.000Z","updated":"2022-05-15T14:20:03.209Z","comments":true,"path":"2022/05/15/Redis数据类型/","link":"","permalink":"http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式 string help @string sting =&gt; byte string内部也包含三种：字符串、数值和bitmap 字符串 set get append setrange getrange strlen 正反向索引： 正向索引：0、1、2、3 反向索引：-1、-2、-3 type命令 type k1: 返回k1表示的value的类型 object object encoding k1: 返回k1表示的value的编码 数值 incr：抢购、秒杀、商品详情，点赞，评论数、好友数，规避并发下对数据库的事物操作，计算向数据移动，完全由redis来替代 incrby incrbyfloat decr decrby bitmap setbit bitcount bitpos bitpop list set zset","categories":[],"tags":[]},{"title":"Redis原理","slug":"Redis原理","date":"2022-05-15T10:21:20.000Z","updated":"2022-05-15T12:07:49.046Z","comments":true,"path":"2022/05/15/Redis原理/","link":"","permalink":"http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/","excerpt":"","text":"Redis相关的原理 一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线程，单实例。客户端可能会有很多个，可能以socket fd形式，连到系统kernel上，redis通过epoll来取数据，单线程，顺序来读取。 顺序性：每个连接内的命令是顺序的 =》衍生kafka topic 分区消息顺序性 使用 启动 通过 redis-cli 命令启动客户端 切换库 redis默认是有16个库，0～15 redis-cli -db select db 不同db之间数据是隔离的 help 通用：help @generic value: help @sting @list @hash Linux BIO 每个连接对应一个线程，Socket在这个时期是blocking的。 同步非阻塞 NIO 对应一个线程，不用阻塞，不用很多的线程。会轮询调用kernel, 检查fd有没有数据。比如有1000个fd，代表用户进程轮询调用1000次kernel。一个线程可以hold住1000个连接，避免每个连接对应一个线程，增加系统成本。在这个期间，会涉及用户和内核空间转换，上下文切换等等，有系统开销，成本比较大。 轮询是发生在用户空间。 线程多了，cpu调度成本高，频繁做线程切换，内存成本高，一个线程占用1MB内存。 多路复用 NIO 调用系统内核的select，将上面的1000个文件描述符全部传进来。只会调用一次，在内核态等待，再返回fd，然后用户空间再通过read调用挨个访问fd。在这个过程中还是会涉及到fd相关的数据拷贝来拷贝去。 epoll epoll create create epfd ctl ctl add delete socket fd wait 等待事件，数据准备好了，放到链表，就可以返回了。 MMAP共享空间 划分出来一个共享空间，内核和用户都可以直接访问。上面的1000个文件描述符直接写入到共享空间，内核直接通过地址访问这个共享空间，避免了fd相关数据的拷贝。 使用红黑树来表示文件描述符 使用链表来表示已经读取好的文件描述符 零拷贝","categories":[],"tags":[]},{"title":"Redis入门","slug":"Redis入门","date":"2022-05-15T06:24:35.000Z","updated":"2022-05-15T07:33:27.353Z","comments":true,"path":"2022/05/15/Redis入门/","link":"","permalink":"http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"Redis常识 为什么需要Redis？ 在软件架构里，数据通常存储在数据库里。数据库存储在磁盘文件里，会受到磁盘IO的影响，存在性能瓶颈。当访问量特别大的时候，频繁访问数据库，磁盘IO比较高，查询性能比较慢。这时候可以适当加上缓存，Redis就是个不错的选择。可以将经常查询的数据放在Redis里，借助Redis数据放在内存，提供的高效的查询能力助力业务。 遇到的问题 引入Redis之后，需要面对一个问题，如何保证数据库和缓存数据的一致性？ 和IO相关的知识 磁盘 说的磁盘会有两个和磁盘相关的指标，一个是寻址，一个是带宽 寻址：一般是在毫秒级别 带宽：单位时间内流过的数据量，一般是G或者MB 内存 内存同样也会有这两个指标 寻址：一般是在纳秒级别 带宽：很大 在寻址方面内存会比磁盘快10W倍。 I/O buffer 磁盘会有磁道和扇区，一个扇区512字节。如果这个容量太小，扇区数就会增加，索引就会增大，会增加管理的成本。 操作系统读取写入数据一般是按照4K个字节为单位来进行存取，即使只需要少量几个字节的信息，也会一次性的读取整个4K字节，提高访问速度。我们在进行磁盘格式化的时候，需要做分区对齐，一般也是4K。 随着磁盘中文件越来越大，访问速度会变慢？这是因为此时磁盘IO成为了瓶颈。 和数据库相关的知识 数据存储 当我们往数据库里放数据，首先需要为其创建一张表，定义好schema，表中包含哪些字段，类型是什么。存储的时候倾向按行来存储，将一条数据包含的所有内容，按照行的形式存到文件里。具体的存储格式和数据库存储引擎相关。 数据查询 当查询没有命中索引，会进行全表扫描，磁盘IO是比较大的。当命中索引时，可以通过索引快速查询出需要的数据，减少不必要的IO。MySQL数据库Innodb存储引擎，索引是通过B+树来实现的，每个节点可以有多个分叉，只有叶子结点存储数据，非叶子结点不存储数据，实现了用很少的层数来索引大量的数据。三层B+树，就可以来表示千万级别的数据量。 表很大，性能下降？ 增删改 有索引，增删改的成本会变高，因为涉及到维护索引。 查询 单个或者少量的查询还是很快，并发大的时候会受到磁盘带宽的影响，速度会变慢（数据量大，即使通过索引命中的数据可能也比较多）。 Redis安装 Redis官网 redis.io 安装步骤 123456789101112131415161718192021222324252627# 1.下载安装包 wget https://github.com/redis/redis/archive/7.0.0.tar.gz# 2.解压缩安装包 tar -zxvf redis-7.0.0.tar.gz# 3.查看README.mdcat README.md# 4.编译安装yum install gccmake make install PREFIX=/opt/redis7make test make distclean# 5.配置环境变量vi /etc/prifileexport REDIS_HOME=/opt/redis7export PATH=$PATH:$REDIS_HOME/binsource /etc/profile# 6.配置系统服务sh utils/install_server.sh# 7.启动停止redisservice redis_6379 start/stop/restart/status This systems seems to use systemd","categories":[],"tags":[]},{"title":"动态年龄","slug":"动态年龄","date":"2022-01-28T07:32:12.000Z","updated":"2022-01-28T07:32:12.067Z","comments":true,"path":"2022/01/28/动态年龄/","link":"","permalink":"http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"标量替换","slug":"标量替换","date":"2022-01-28T07:31:19.000Z","updated":"2022-01-28T07:31:19.565Z","comments":true,"path":"2022/01/28/标量替换/","link":"","permalink":"http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[],"tags":[]}