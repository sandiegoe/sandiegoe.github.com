<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arexstorm个人工作站</title>
  
  
  <link href="http://sandiegoe.github.io/atom.xml" rel="self"/>
  
  <link href="http://sandiegoe.github.io/"/>
  <updated>2022-05-17T14:55:02.331Z</updated>
  <id>http://sandiegoe.github.io/</id>
  
  <author>
    <name>Arexstorm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据类型</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-15T13:37:12.000Z</published>
    <updated>2022-05-17T14:55:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式</p><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h1><p>string表示的是value的类型，string有三类操作，针对字符串、针对数值和针对bitmap</p><blockquote><p>help @string</p></blockquote><p>sting =&gt; byte</p><p>string内部也包含三种：字符串、数值和bitmap</p><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><p><code>set</code><br /><code>get</code><br /><code>append</code><br /><code>setrange</code><br /><code>getrange</code><br /><code>strlen</code>：看的是有多少个字节，abcd长度为4，99999长度为5</p><h3 id="正反向索引"><a class="markdownIt-Anchor" href="#正反向索引"></a> 正反向索引：</h3><p>正向索引：0、1、2、3<br />反向索引：-1、-2、-3</p><h3 id="type命令"><a class="markdownIt-Anchor" href="#type命令"></a> type命令</h3><p><code>type k1</code>: 返回k1表示的value的类型</p><h3 id="object"><a class="markdownIt-Anchor" href="#object"></a> object</h3><p><code>object encoding k1</code>: 返回k1表示的value的编码</p><h3 id="二进制安全"><a class="markdownIt-Anchor" href="#二进制安全"></a> 二进制安全</h3><p>redis进程和外界交互的时候，使用的是字节流，底层存储也是二进制字节，通过encoding可以辅助判断，如果是int，可以直接incr，能够提高速度<br />中文一个字符utf8是三个字节，gbk是两个字节<br />hbase也是二进制安全的</p><h2 id="数值"><a class="markdownIt-Anchor" href="#数值"></a> 数值</h2><p><code>incr</code>：抢购、秒杀、商品详情，点赞，评论数、好友数，规避并发下对数据库的事物操作，计算向数据移动，完全由redis来替代<br /><code>incrby</code><br /><code>incrbyfloat</code><br /><code>decr</code><br /><code>decrby</code></p><h2 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> bitmap</h2><p><code>help setbit</code><br /><code>setbit</code><br /><code>bitcount</code>：返回start-end字节中统计1出现的次数<br /><code>bitpos</code>：返回第start-end字节的bit为指定值的位置<br /><code>bitop</code>：bitop operation destkey key [key …]，执行bit操作，operation与或非，destkey写入的目标key，key参与运算的key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit k1 1 1</span><br><span class="line">strlen k1 =&gt; 1</span><br><span class="line">getbit k1 =&gt; @</span><br><span class="line">setbit k1 9 1 </span><br><span class="line">strlen k1 =&gt; 2</span><br></pre></td></tr></table></figure><p>man ascii</p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><p><code>用户系统</code>：统计用户的登录天数，且窗口随机</p><p><code>618活动，登录就送礼物</code>：仓库备货多少礼物，假设2亿用户<br />僵尸用户、冷热用户/忠诚用户<br />活跃用户统计，随机窗口<br />以天为key，每个key中的每个bit表示每个用户，需要做用户和bit的下标做映射</p><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h1><p>list是有序(说的是插入的顺序)，能够保存重复元素，为list类型的key会包含两个属性，head，tail用来指向链表的头节点和尾节点。</p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><p><code>help @list</code><br /><code>lpush</code>：往左边添加元素<br /><code>rpush</code>：往右边添加元素<br /><code>lpop</code>：弹出一个左边的元素<br /><code>rpop</code>：弹出一个右边的元素<br /><code>lrange</code>：看start-end的元素集合<br /><code>lindex</code>：查看某个索引位置的元素<br /><code>lset</code>：设置某个索引位置的元素<br /><code>lrem</code>：从list中移除count个元素，其值为value；count为正数，从左往右，为负数，从右往走<br /><code>linsert</code>：从某个位置插入一个元素<br /><code>llen</code><br /><code>blpop</code>：阻塞的左边弹<br /><code>ltrim</code>：移除start-end两端等数据</p><h2 id="使用场景-2"><a class="markdownIt-Anchor" href="#使用场景-2"></a> 使用场景</h2><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>可以用list来表示栈结构，使用同向命令</p><h3 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h3><p>用list来表示队列，使用反向命令</p><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>用list来表示数组，通过下标lindex, lset等</p><h3 id="阻塞-单播队列-fifo"><a class="markdownIt-Anchor" href="#阻塞-单播队列-fifo"></a> 阻塞 单播队列 FIFO</h3><p>使用blpop、lpush</p><h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h1><p>类似java中的HashMap，健值对形式</p><h2 id="常用命令-2"><a class="markdownIt-Anchor" href="#常用命令-2"></a> 常用命令</h2><p><code>hset</code><br /><code>hmset</code><br /><code>hget</code><br /><code>hmget</code><br /><code>hkeys</code><br /><code>kvals</code><br /><code>hgetall</code><br /><code>hincrbyfloat</code></p><h2 id="使用场景-3"><a class="markdownIt-Anchor" href="#使用场景-3"></a> 使用场景</h2><p>对field进行数值计算</p><h3 id="商品详情页"><a class="markdownIt-Anchor" href="#商品详情页"></a> 商品详情页</h3><h3 id="点赞-收藏-分享数"><a class="markdownIt-Anchor" href="#点赞-收藏-分享数"></a> 点赞、收藏、分享数</h3><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h1><p>是一个集合，集合内的元素不重复，无序。</p><h2 id="常用命令-3"><a class="markdownIt-Anchor" href="#常用命令-3"></a> 常用命令</h2><p><code>sadd</code><br /><code>smembers</code><br /><code>srem</code><br /><code>scard</code><br /><code>sinter</code>：取集合交集<br /><code>sinterstore</code>：交集的结果存储到某一个key里，没有IO<br /><code>sunion</code>：取集合到并集<br /><code>sunionstore</code><br /><code>sdiff</code>：返回集合的差集<br /><code>srandomemember</code>：随机返回一个集合中的元素，count为正数，取出一个去重的结果集（不能超过已有的结果集），count负数，可以取出一个带重复的结果集合，一定满足你要的数量，如果count为0，就不返回<br /><code>spop</code></p><h2 id="使用场景-4"><a class="markdownIt-Anchor" href="#使用场景-4"></a> 使用场景</h2><h3 id="抽奖一次抽多个"><a class="markdownIt-Anchor" href="#抽奖一次抽多个"></a> 抽奖(一次抽多个)</h3><p>使用srandomemember来实现，一个key中存放粉丝用户，+3 给你返回三个且去重，-3 给你反回允许重复</p><h3 id="抽奖一次抽一个不能重复抽"><a class="markdownIt-Anchor" href="#抽奖一次抽一个不能重复抽"></a> 抽奖(一次抽一个，不能重复抽)</h3><p>spop</p><h1 id="sorted-setzset"><a class="markdownIt-Anchor" href="#sorted-setzset"></a> sorted set(zset)</h1><p>去重且有序，按照score来进行排序。在内存里是按照链表来存储，默认左小右大的物理摆放顺序</p><h2 id="常用命令-4"><a class="markdownIt-Anchor" href="#常用命令-4"></a> 常用命令</h2><p><code>zadd</code><br /><code>zrange</code><br /><code>zrangebyscore</code><br /><code>zrevrange</code><br /><code>zscore</code><br /><code>zrank</code>：取出排名<br /><code>zincrby</code><br /><code>zunionstore</code></p><h2 id="排序怎么实现的"><a class="markdownIt-Anchor" href="#排序怎么实现的"></a> 排序怎么实现的</h2><p>底层是通过skiplist跳跃表(类平衡树)数据结构来实现的。每个元素插入的时候随机造层，越往上，节点数越少。针对增删改大量操作，平均值相对最优。</p><p><img src="https://pic4.zhimg.com/80/v2-1cc963c19eb34db31c47ef69a15f6863_1440w.jpg" alt="skiplist" /></p><h2 id="使用场景-5"><a class="markdownIt-Anchor" href="#使用场景-5"></a> 使用场景</h2><h3 id="榜单"><a class="markdownIt-Anchor" href="#榜单"></a> 榜单</h3><p>使用zrevrange命令取出前N</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式&lt;/p&gt;
&lt;h1 id=&quot;string&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-15T10:21:20.000Z</published>
    <updated>2022-05-16T06:19:22.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis相关的原理"><a class="markdownIt-Anchor" href="#redis相关的原理"></a> Redis相关的原理</h1><p>一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线程，单实例。客户端可能会有很多个，可能以socket fd形式，连到系统kernel上，redis通过epoll来取数据，单线程，顺序来读取。</p><blockquote><p>顺序性：每个连接内的命令是顺序的 =》衍生kafka topic 分区消息顺序性</p></blockquote><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><p>通过 <code>redis-cli</code> 命令启动客户端</p><h3 id="切换库"><a class="markdownIt-Anchor" href="#切换库"></a> 切换库</h3><p>redis默认是有16个库，0～15</p><blockquote><p>redis-cli -db<br />select db<br />不同db之间数据是隔离的</p></blockquote><h3 id="help"><a class="markdownIt-Anchor" href="#help"></a> help</h3><p>通用：help @generic</p><p>value: help @sting @list @hash</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h2><p>每个连接对应一个线程，Socket在这个时期是blocking的。</p><h2 id="同步非阻塞-nio"><a class="markdownIt-Anchor" href="#同步非阻塞-nio"></a> 同步非阻塞 NIO</h2><p>对应一个线程，不用阻塞，不用很多的线程。会轮询调用kernel, 检查fd有没有数据。比如有1000个fd，代表用户进程轮询调用1000次kernel。一个线程可以hold住1000个连接，避免每个连接对应一个线程，增加系统成本。在这个期间，会涉及用户和内核空间转换，上下文切换等等，有系统开销，成本比较大。</p><blockquote><p>轮询是发生在用户空间。<br />线程多了，cpu调度成本高，频繁做线程切换，内存成本高，一个线程占用1MB内存。</p></blockquote><h2 id="多路复用-nio"><a class="markdownIt-Anchor" href="#多路复用-nio"></a> 多路复用 NIO</h2><p>调用系统内核的select，将上面的1000个文件描述符全部传进来。只会调用一次，在内核态等待，再返回fd，然后用户空间再通过read调用挨个访问fd。在这个过程中还是会涉及到fd相关的数据拷贝来拷贝去。</p><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><h3 id="epoll-create"><a class="markdownIt-Anchor" href="#epoll-create"></a> epoll create</h3><p>create epfd</p><h3 id="ctl"><a class="markdownIt-Anchor" href="#ctl"></a> ctl</h3><p>ctl add delete socket fd</p><h3 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h3><p>等待事件，数据准备好了，放到链表，就可以返回了。</p><h3 id="mmap共享空间"><a class="markdownIt-Anchor" href="#mmap共享空间"></a> MMAP共享空间</h3><p>划分出来一个共享空间，内核和用户都可以直接访问。上面的1000个文件描述符直接写入到共享空间，内核直接通过地址访问这个共享空间，避免了fd相关数据的拷贝。</p><blockquote><p>使用红黑树来表示文件描述符<br />使用链表来表示已经读取好的文件描述符</p></blockquote><h2 id="零拷贝"><a class="markdownIt-Anchor" href="#零拷贝"></a> 零拷贝</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis相关的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis相关的原理&quot;&gt;&lt;/a&gt; Redis相关的原理&lt;/h1&gt;
&lt;p&gt;一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-15T06:24:35.000Z</published>
    <updated>2022-05-15T07:33:27.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis常识"><a class="markdownIt-Anchor" href="#redis常识"></a> Redis常识</h1><h2 id="为什么需要redis"><a class="markdownIt-Anchor" href="#为什么需要redis"></a> 为什么需要Redis？</h2><p>在软件架构里，数据通常存储在数据库里。数据库存储在磁盘文件里，会受到磁盘IO的影响，存在性能瓶颈。当访问量特别大的时候，频繁访问数据库，磁盘IO比较高，查询性能比较慢。这时候可以适当加上缓存，Redis就是个不错的选择。可以将经常查询的数据放在Redis里，借助Redis数据放在内存，提供的高效的查询能力助力业务。</p><h2 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h2><p>引入Redis之后，需要面对一个问题，如何保证数据库和缓存数据的一致性？</p><h2 id="和io相关的知识"><a class="markdownIt-Anchor" href="#和io相关的知识"></a> 和IO相关的知识</h2><h3 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h3><p>说的磁盘会有两个和磁盘相关的指标，一个是寻址，一个是带宽</p><ul><li>寻址：一般是在毫秒级别</li><li>带宽：单位时间内流过的数据量，一般是G或者MB</li></ul><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p>内存同样也会有这两个指标</p><ul><li>寻址：一般是在纳秒级别</li><li>带宽：很大</li></ul><p>在寻址方面内存会比磁盘快10W倍。</p><h3 id="io-buffer"><a class="markdownIt-Anchor" href="#io-buffer"></a> I/O buffer</h3><p>磁盘会有磁道和扇区，一个扇区512字节。如果这个容量太小，扇区数就会增加，索引就会增大，会增加管理的成本。<br />操作系统读取写入数据一般是按照4K个字节为单位来进行存取，即使只需要少量几个字节的信息，也会一次性的读取整个4K字节，提高访问速度。我们在进行磁盘格式化的时候，需要做分区对齐，一般也是4K。</p><blockquote><p>随着磁盘中文件越来越大，访问速度会变慢？这是因为此时磁盘IO成为了瓶颈。</p></blockquote><h2 id="和数据库相关的知识"><a class="markdownIt-Anchor" href="#和数据库相关的知识"></a> 和数据库相关的知识</h2><h3 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h3><p>当我们往数据库里放数据，首先需要为其创建一张表，定义好schema，表中包含哪些字段，类型是什么。存储的时候倾向按行来存储，将一条数据包含的所有内容，按照行的形式存到文件里。具体的存储格式和数据库存储引擎相关。</p><h3 id="数据查询"><a class="markdownIt-Anchor" href="#数据查询"></a> 数据查询</h3><p>当查询没有命中索引，会进行全表扫描，磁盘IO是比较大的。当命中索引时，可以通过索引快速查询出需要的数据，减少不必要的IO。MySQL数据库Innodb存储引擎，索引是通过B+树来实现的，每个节点可以有多个分叉，只有叶子结点存储数据，非叶子结点不存储数据，实现了用很少的层数来索引大量的数据。三层B+树，就可以来表示千万级别的数据量。</p><h3 id="表很大性能下降"><a class="markdownIt-Anchor" href="#表很大性能下降"></a> 表很大，性能下降？</h3><h4 id="增删改"><a class="markdownIt-Anchor" href="#增删改"></a> 增删改</h4><p>有索引，增删改的成本会变高，因为涉及到维护索引。</p><h4 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h4><p>单个或者少量的查询还是很快，并发大的时候会受到磁盘带宽的影响，速度会变慢（数据量大，即使通过索引命中的数据可能也比较多）。</p><h1 id="redis安装"><a class="markdownIt-Anchor" href="#redis安装"></a> Redis安装</h1><h2 id="redis官网"><a class="markdownIt-Anchor" href="#redis官网"></a> Redis官网</h2><p><a href="https://redis.io/">redis.io</a></p><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.下载安装包</span> </span><br><span class="line">wget https://github.com/redis/redis/archive/7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.解压缩安装包</span> </span><br><span class="line">tar -zxvf redis-7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.查看README.md</span></span><br><span class="line">cat README.md</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.编译安装</span></span><br><span class="line">yum install gcc</span><br><span class="line">make </span><br><span class="line">make install PREFIX=/opt/redis7</span><br><span class="line">make test </span><br><span class="line">make distclean</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.配置环境变量</span></span><br><span class="line">vi /etc/prifile</span><br><span class="line">export REDIS_HOME=/opt/redis7</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.配置系统服务</span></span><br><span class="line">sh utils/install_server.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.启动停止redis</span></span><br><span class="line">service redis_6379 start/stop/restart/status</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_44187615/article/details/111079601">This systems seems to use systemd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis常识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis常识&quot;&gt;&lt;/a&gt; Redis常识&lt;/h1&gt;
&lt;h2 id=&quot;为什么需要redis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么需</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态年龄</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/</id>
    <published>2022-01-28T07:32:12.000Z</published>
    <updated>2022-01-28T07:32:12.067Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>标量替换</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/</id>
    <published>2022-01-28T07:31:19.000Z</published>
    <updated>2022-01-28T07:31:19.565Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
