<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arexstorm个人工作站</title>
  
  
  <link href="http://sandiegoe.github.io/atom.xml" rel="self"/>
  
  <link href="http://sandiegoe.github.io/"/>
  <updated>2022-05-26T07:33:16.677Z</updated>
  <id>http://sandiegoe.github.io/</id>
  
  <author>
    <name>Arexstorm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL事物和索机制</title>
    <link href="http://sandiegoe.github.io/2022/05/25/MySQL%E4%BA%8B%E7%89%A9%E8%A7%A3%E6%9E%90/"/>
    <id>http://sandiegoe.github.io/2022/05/25/MySQL%E4%BA%8B%E7%89%A9%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-24T16:19:08.000Z</published>
    <updated>2022-05-26T07:33:16.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是事物"><a class="markdownIt-Anchor" href="#什么是事物"></a> 什么是事物</h1><p>事物是指逻辑上的一组操作，要么全部都执行，要么全部不执行。事物可以分为数据库事物和分布式事物。本文主要说明的事数据库事物。</p><h2 id="事物的四个特性acid"><a class="markdownIt-Anchor" href="#事物的四个特性acid"></a> 事物的四个特性ACID</h2><p>说起事物一般都会说起其四大特性，原子性、一致性、隔离性和持久性。这几个特性之间的关系是，原子、隔离和持久是手段方法，通过这几个方法来实现一致，因此一致是目标。</p><ul><li>A(原子性)：通过undolog来实现</li></ul><blockquote><p>事物执行的最小单元，不能再拆分。一个事物中可以包含多个操作，这个多个操作要呢全部执行，要么全部不执行。</p></blockquote><ul><li>C(一致性)：通过A、I和D来实现</li></ul><blockquote><p>事物执行前后数据保持一致，比如在转账场景中，不管事物执行怎么样，总钱数是不变的。</p></blockquote><ul><li>I(隔离性)：通过锁和MVCC来实现</li></ul><blockquote><p>一个事物不会受到另外一个事物的影响，数据库的多个事物之间彼此是相互独立的。</p></blockquote><ul><li>D(持久性)：通过redolog来实现</li></ul><blockquote><p>事物一旦执行成功，就会永久保存，不管数据库发生什么故障，都不应该会对其有影响。</p></blockquote><h2 id="并发事物的几个问题"><a class="markdownIt-Anchor" href="#并发事物的几个问题"></a> 并发事物的几个问题</h2><h3 id="脏读"><a class="markdownIt-Anchor" href="#脏读"></a> 脏读</h3><p>A、B两个事物，A事物读取到了B事物中未提交的数据，这种就称之为脏读，数据是异常的。</p><h3 id="丢失修改"><a class="markdownIt-Anchor" href="#丢失修改"></a> 丢失修改</h3><p>A、B两个事物都对同一条数据进行更新，A事物修改完提交，B事物再修改提交，最后该数据是B事物修改之后的样子，丢失了第一条事物对数据的修改。</p><h3 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h3><p>A、B两个事物，A事物查询了一条数据，B事物中修改了该数据的部分列，A事物随后再次查询，前后两次查询的数据不一样，这就是不可重复读。</p><h3 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h3><p>A、B两个事物，A事物查询了一些数据，B事物中插入或者删除了符合A事物中查询提交的数据，随后A事物再次查询，发现多了或者少了一部分记录，这就是幻读。</p><p>产生的原因：快照读和当前读一起使用，如果一个事物中只有快照读，那么就不会有幻读的问题。</p><p><code>不可重复读</code>和<code>幻读</code>比较相似，<code>不可重复读</code>强调的是对于已有数据的修改，<code>幻读</code>强调的是插入或者删除了数据。</p><h2 id="事物隔离级别"><a class="markdownIt-Anchor" href="#事物隔离级别"></a> 事物隔离级别</h2><p>事物隔离级别是一个参数，可以通过调整这个参数来控制MySQL的行为。</p><h3 id="read-uncommitted"><a class="markdownIt-Anchor" href="#read-uncommitted"></a> READ-UNCOMMITTED</h3><p>读未提交，最低的隔离级别，会出现脏读、不可重复读和幻读的问题。</p><h3 id="read-committed"><a class="markdownIt-Anchor" href="#read-committed"></a> READ-COMMITTED</h3><p>读已提交，大多数数据库的隔离级别都是<code>READ-COMMITTED</code>，可以解决脏读的问题，但是还会出现不可重复读和幻读的问题。</p><h3 id="repeatable-read"><a class="markdownIt-Anchor" href="#repeatable-read"></a> REPEATABLE-READ</h3><p>重复读，是MySQL默认的隔离级别。可以解决脏读、不可重复读的问题，但是会出现幻读的问题。</p><h3 id="serializable"><a class="markdownIt-Anchor" href="#serializable"></a> SERIALIZABLE</h3><p>最高的隔离级别，多个事物之间挨个执行，可以解决脏读、不可重复读和幻读的问题，但是对于性能的影响也是最高。</p><h2 id="mysql默认隔离级别"><a class="markdownIt-Anchor" href="#mysql默认隔离级别"></a> MySQL默认隔离级别</h2><p>MySQL默认的隔离级别是REPEATABLE-READ。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@trasaction</span>_isolation;</span><br></pre></td></tr></table></figure><h1 id="mysql的几种log"><a class="markdownIt-Anchor" href="#mysql的几种log"></a> MySQL的几种log</h1><p><code>undolog</code></p><blockquote><p>回滚日志，为了实现原子性和MVCC<br />innodb存储引擎才有<br />记录了数据的多个版本，通过一个链表的形式来链接，链首是最新的数据版本，链尾诗最旧的数据版本</p></blockquote><p><code>redolog</code></p><blockquote><p>前滚日志，为了实现持久性<br />innodb存储引擎才有</p></blockquote><p><code>binlog</code></p><blockquote><p>实现主从复制的</p></blockquote><p><code>relaylog</code></p><blockquote><p>中继日志，在进行主从复制里，从机存储的日志文件</p></blockquote><p><code>slowlog</code></p><blockquote><p>慢查询日志</p></blockquote><p><code>error.log</code></p><blockquote><p>错误日志</p></blockquote><h1 id="二阶段提交"><a class="markdownIt-Anchor" href="#二阶段提交"></a> 二阶段提交</h1><p>这里主要说的是redolog和binlog之间怎么保证数据的一致性，我们都知道redolog是用来保证持久性的，binlog是用来做主从复制的。MySQL在保存一条数据的时候，是先存redolog呢，还是先存binlog呢？</p><p>在MySQL中通过二阶段提交来保证数据的一致性：</p><ul><li>redolog prepare</li><li>binlog</li><li>redolog commit</li></ul><h1 id="mvcc机制"><a class="markdownIt-Anchor" href="#mvcc机制"></a> MVCC机制</h1><p>MVCC中文是多版本并发控制。重点是解决并发读写场景的数据一致性问题。</p><h2 id="当前读"><a class="markdownIt-Anchor" href="#当前读"></a> 当前读</h2><p>读取的永远是最新的数据，不会读取到历史数据。update、delete、insert、select for update、select in share mode操作会触发当前读。</p><h2 id="快照读"><a class="markdownIt-Anchor" href="#快照读"></a> 快照读</h2><p>读取的是历史版本数据，不是最新的数据。select操作会触发快照读。</p><h2 id="隐藏字段"><a class="markdownIt-Anchor" href="#隐藏字段"></a> 隐藏字段</h2><p>数据库表除了包含我们声明的字段外，还会包含一些隐藏字段。MySQL中主要包含一下三个隐藏字段：<br /><code>DB_TRX_ID</code>：最近修改的事物ID，创建这条记录或者最近一次更新这条记录的事物ID<br /><code>DB_ROLL_PTR</code>：回滚指针，指向记录的上一个版本<br /><code>DB_ROW_ID</code>：隐藏主键，MySQL表中没有主键，会自动生成6个字节的row_id</p><h2 id="readview"><a class="markdownIt-Anchor" href="#readview"></a> readview</h2><p>在事物进行快照读的时候产生的<code>读视图</code>，保存的并不是真实数据，而是事物信息。<br /><code>trx_list</code></p><blockquote><p>当前系统活跃事物ID列表</p></blockquote><p><code>up_limit_id</code></p><blockquote><p>活跃列表中事物ID最小的值</p></blockquote><p><code>down_limit_id</code></p><blockquote><p>尚未分配的下一个事物ID</p></blockquote><h2 id="可见性算法"><a class="markdownIt-Anchor" href="#可见性算法"></a> 可见性算法</h2><ul><li>首先比较DB_TRX_ID &lt; up_limit_id,如果小于，则当前事务能看到DB_TRX_ID所在的记录，如果大于等于进入下一个判断</li><li>接下来判断DB_TRX_ID &gt;= low_limit_id,如果大于等于则代表DB_TRX_ID所在的记录在Read View生成后才出现的，那么对于当前事务肯定不可见，如果小于，则进入下一步判断</li><li>判断DB_TRX_ID是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，修改的数据，当前事务也是看不到，如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</li></ul><h2 id="case"><a class="markdownIt-Anchor" href="#case"></a> CASE</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h3><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220526151103.png" alt="" /></p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h3><p>第一次查询的时候创建了读视图，第二次沿用了第一次的读视图</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220526151907.png" alt="" /></p><h2 id="和事物隔离级别的关闭"><a class="markdownIt-Anchor" href="#和事物隔离级别的关闭"></a> 和事物隔离级别的关闭</h2><p>如果<code>READ-COMMITTED</code>隔离级别，每次在进行快照读读时候都会产生新的读视图，这就是<code>READ-COMMITTED</code>会存在不可重复读的问题</p><p>如果是<code>REPEATABLE-READ</code>隔离级别，只有在该事物第一次快照读读时候产生读视图，后面都是沿用第一次读视图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是事物&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是事物&quot;&gt;&lt;/a&gt; 什么是事物&lt;/h1&gt;
&lt;p&gt;事物是指逻辑上的一组操作，要么全部都执行，要么全部不执行。事物可以分为数据库事物和分布式事物。本文主要说明的事数据库事物。&lt;/</summary>
      
    
    
    
    <category term="MySQL" scheme="http://sandiegoe.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://sandiegoe.github.io/tags/MySQL/"/>
    
    <category term="事物" scheme="http://sandiegoe.github.io/tags/%E4%BA%8B%E7%89%A9/"/>
    
    <category term="MVCC" scheme="http://sandiegoe.github.io/tags/MVCC/"/>
    
    <category term="锁" scheme="http://sandiegoe.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化机制解析(RDB和AOF)</title>
    <link href="http://sandiegoe.github.io/2022/05/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90-RDB%E5%92%8CAOF/"/>
    <id>http://sandiegoe.github.io/2022/05/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90-RDB%E5%92%8CAOF/</id>
    <published>2022-05-23T00:24:00.000Z</published>
    <updated>2022-05-23T02:52:54.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis持久化的几种方式"><a class="markdownIt-Anchor" href="#redis持久化的几种方式"></a> Redis持久化的几种方式</h1><p>Redis支持两种方式持久化，分别是RDB和AOF，各有优缺点。通过持久化，可以避免Redis缓存数据丢失，保证数据安全。</p><h1 id="rdb"><a class="markdownIt-Anchor" href="#rdb"></a> RDB</h1><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><ul><li>RDB是将当前进程内的数据生成一份快照保存到磁盘上</li><li>时点性：间隔固定时间或者指定次数操作后触发</li></ul><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`save m n`：m秒内执行n次操作触发bgsave</span><br><span class="line">`stop-writes-on-bgsave-error yes`</span><br><span class="line">`rdbcompression yes`</span><br><span class="line">`rdbchecksum yes`</span><br><span class="line">`dbfilename dump.rdb`</span><br><span class="line">`dir /var/lib/redis/6379`</span><br></pre></td></tr></table></figure><h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2><ul><li>执行bgsave命令</li><li>父进程会fork一个子进程，fork期间是阻塞的，info stats查看latest_fork_usec获取最近一个fork操作的耗时，单位是微妙</li><li>父进程fork完，bgsave命令返回&quot;Background saving started&quot;</li><li>子进程创建rdb文件，并替换原有的rdb文件</li><li>子进程发送信号给父进程表示完成，更新统计信息</li></ul><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220523092743.png" alt="" /></p><h2 id="触发"><a class="markdownIt-Anchor" href="#触发"></a> 触发</h2><p>有两种方式触发，一种手动，一种通过配置的策略自动触发</p><h3 id="手动"><a class="markdownIt-Anchor" href="#手动"></a> 手动</h3><p><code>save</code>: 阻塞方式生成快照，生成快照期间，客户端查询将会被阻塞<br /><code>bgsave</code>: 非阻塞方式生成快照</p><h3 id="自动"><a class="markdownIt-Anchor" href="#自动"></a> 自动</h3><h4 id="在redis配置文件中配置触发规则"><a class="markdownIt-Anchor" href="#在redis配置文件中配置触发规则"></a> 在redis配置文件中配置触发规则</h4><p><code>save m n</code>：m秒内发生n次操作就触发生成快照，非阻塞方式</p><h4 id="从节点执行全量复制"><a class="markdownIt-Anchor" href="#从节点执行全量复制"></a> 从节点执行全量复制</h4><p>当从节点执行全量复制时，主节点会执行bgsave</p><h4 id="debug-reload"><a class="markdownIt-Anchor" href="#debug-reload"></a> debug reload</h4><p>执行debug reload重新加载Redis时，也会触发save操作</p><h4 id="shutdown"><a class="markdownIt-Anchor" href="#shutdown"></a> shutdown</h4><p>默认情况执行shutdown，如果没有配置AOF也会自动执行bgsave</p><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>是一个紧凑的二进制文件，代表某个时间点上的快照，试用于备份</li><li>相比于AOF恢复速度快</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li>容易丢失数据：在生成下一次快照之前，如果Redis发生故障，在这段时间内的数据会丢失</li><li>不支持拉链：只会保留最新的一个rdb文件</li></ul><h1 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h1><h2 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h2><ul><li>AOF是另外一种持久化方式，它是以日志文件的格式来记录Redis操作的命令，当redis重启时，通过重新执行日志文件中的命令来恢复数据</li><li>在redis中，AOF和RDB可以同时开启</li><li>如果开启了AOF，那么只会用AOF来恢复</li><li>在Redis4.0以后，AOF文件中包含RDB全量，以及之后的增量操作日志</li></ul><h2 id="配置-2"><a class="markdownIt-Anchor" href="#配置-2"></a> 配置</h2><p><code>appendonly yes</code>：开启AOF<br /><code>appendfilename &quot;appendonly.aof&quot;</code>：aof文件名称<br /><code>appenddirname &quot;appendonlydir&quot;</code>：持久化AOF文件目录<br /><code>appendfsync</code>：刷盘策略，默认是<code>everysec</code><br /><code>no-appendfsync-on-rewrite no</code><br /><code>auto-aof-rewrite-min-size 64mb</code>：表示运行AOF重写时文件最小的体积<br /><code>auto-aof-rewrite-percentage 100</code>：表示当前AOF文件大小(aof_current_size)和上一次重写之后的AOF文件空间(aof_base_size)的比值<br /><code>aof-load-truncated yes</code></p><h3 id="刷盘策略"><a class="markdownIt-Anchor" href="#刷盘策略"></a> 刷盘策略</h3><h4 id="everysec"><a class="markdownIt-Anchor" href="#everysec"></a> everysec</h4><p>每秒钟进行一次刷盘，将aof_buffer中的数据写到磁盘中，最多丢失1s内的数据</p><h3 id="no"><a class="markdownIt-Anchor" href="#no"></a> no</h3><p>依赖操作系统自己的fsync机制</p><h3 id="always"><a class="markdownIt-Anchor" href="#always"></a> always</h3><p>每加一个，就刷一次</p><h2 id="流程-2"><a class="markdownIt-Anchor" href="#流程-2"></a> 流程</h2><ul><li>写命令会追加到aof_buffer中</li><li>aof_buffer会根据对应的策略向硬盘做同步操作</li><li>随着文件越来越大，aof文件会进行重写，达到压缩目的</li><li>当redis重启时，会加载读取aof文件来恢复数据</li></ul><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220523105249.png" alt="" /></p><h3 id="重写机制"><a class="markdownIt-Anchor" href="#重写机制"></a> 重写机制</h3><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220523104624.png" alt="" /></p><h3 id="重启加载"><a class="markdownIt-Anchor" href="#重启加载"></a> 重启加载</h3><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220523104549.png" alt="" /></p><h2 id="触发-2"><a class="markdownIt-Anchor" href="#触发-2"></a> 触发</h2><h3 id="手动-2"><a class="markdownIt-Anchor" href="#手动-2"></a> 手动</h3><p><code>bgrewriteaof</code></p><h3 id="自动-2"><a class="markdownIt-Anchor" href="#自动-2"></a> 自动</h3><p>根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage 100</code>参数来自动触发</p><p>触发时机：aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp;  (aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage</p><h2 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h2><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>数据不易丢失</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><ul><li>恢复速度慢</li><li>文件体积大</li></ul><h4 id="类比hdfs"><a class="markdownIt-Anchor" href="#类比hdfs"></a> 类比hdfs</h4><p>fsimage + edits.log，让日志只是记录增量的部分</p><h4 id="40前"><a class="markdownIt-Anchor" href="#40前"></a> 4.0前</h4><p>aof文件重写，删除抵消的命令，合并重复的命令，最终得到也是一个纯指令的日志文件</p><h4 id="40以后"><a class="markdownIt-Anchor" href="#40以后"></a> 4.0以后</h4><p>重写，将老的数据rdb到aof文件中，增量以指令的方式追加到aof文件。aof文件是一个混合体，利用了rdb的快，利用了日志到全量</p><h1 id="fork子进程"><a class="markdownIt-Anchor" href="#fork子进程"></a> fork子进程</h1><p>父进程fork出子进程时，此时并不会拷贝内存数据，夫子进程都可以访问内存中的数据，且是一致的。当某个进程修改数据的时候，会使用copy on write技术，先copy出一份数据，然后再修改，确保自己的修改不会影响到其它进程。</p><h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2><ul><li>起到连接作用，前一个命令的输出作为第二个命令的输入</li><li>管道会触发创建子进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo $$</span><br><span class="line">echo $BASHPID</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> $$ 优先级高于 |</span> </span><br><span class="line">echo $$ | more </span><br><span class="line">echo $BASHPID | more </span><br></pre></td></tr></table></figure><h2 id="linux父子进程"><a class="markdownIt-Anchor" href="#linux父子进程"></a> linux父子进程</h2><p>父进程的数据，子进程能否看到？</p><ul><li>常规思想，进程的数据是相互隔离的</li><li>进阶思想，父进程可以让子进程看到数据</li><li>在linux中，export的环境变量，子进程的修改不会影响父进程，父进程的修改也不会影响子进程</li><li>redis中fork子进程，速度很快，占用空间很小</li></ul><p><code>fork.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;bashpid $BASHPID&quot;</span><br><span class="line">echo &quot;child start $num&quot;</span><br><span class="line">sleep 30</span><br><span class="line">echo &quot;child second $num&quot;</span><br><span class="line">num=888</span><br><span class="line">echo &quot;child end $num&quot;</span><br></pre></td></tr></table></figure><p><code>调用</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num=999</span><br><span class="line">echo $BASHPID</span><br><span class="line">echo $num </span><br><span class="line">export num</span><br><span class="line"></span><br><span class="line">echo $num</span><br><span class="line">./fork.sh &amp;</span><br><span class="line">echo $num</span><br><span class="line">num=10</span><br><span class="line">echo $num</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis持久化的几种方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis持久化的几种方式&quot;&gt;&lt;/a&gt; Redis持久化的几种方式&lt;/h1&gt;
&lt;p&gt;Redis支持两种方式持久化，分别是RDB和AOF，各有优缺点。通过持久化，可</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
    <category term="RDB" scheme="http://sandiegoe.github.io/tags/RDB/"/>
    
    <category term="AOF" scheme="http://sandiegoe.github.io/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>Redis的两种使用场景：缓存和数据库</title>
    <link href="http://sandiegoe.github.io/2022/05/22/Redis%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://sandiegoe.github.io/2022/05/22/Redis%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-05-22T14:30:34.000Z</published>
    <updated>2022-05-22T14:57:41.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的使用场景"><a class="markdownIt-Anchor" href="#redis的使用场景"></a> Redis的使用场景</h1><p>Redis有两种典型的使用场景，一个是把Redis作为缓存来使用，另一个是把Redis作为数据库来使用。针对不同使用场景，对于Redis的要求也是不一样的。</p><h1 id="作为缓存"><a class="markdownIt-Anchor" href="#作为缓存"></a> 作为缓存</h1><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><ul><li>缓存的数据不重要，是允许丢的</li><li>不是全量数据</li><li>随着请求缓存的数据会变化：内存大小是有限制的，不可能一直放，将热点数据放入缓存，非热点数据移除缓存</li><li>存放的是热数据</li></ul><h2 id="随着请求缓存的数据会变化"><a class="markdownIt-Anchor" href="#随着请求缓存的数据会变化"></a> 随着请求缓存的数据会变化</h2><h3 id="业务逻辑"><a class="markdownIt-Anchor" href="#业务逻辑"></a> 业务逻辑</h3><p>key是有有效期的</p><ul><li>key的访问不会影响缓存key的过期时间</li><li>key更新，会移除key的过期时间，如果更新的时候未指定过期时间</li><li>有效期随着时间不断减少，到达时间，key就被淘汰了</li><li>可以实现定时，比如统一24:00过期</li></ul><p>怎么实现过期？</p><ul><li>被动：访问该key的时候，判断有没有过期，如果过期自动删掉并返回空</li><li>主动：通过轮询，周期性的方式来扫描过期的key来删除</li></ul><h3 id="业务运转"><a class="markdownIt-Anchor" href="#业务运转"></a> 业务运转</h3><p>内存是有限的，随着访问应该要淘汰掉冷数据</p><ul><li>maxmemory bytes：设置Redis最大内存</li><li>maxmemory-policy：到达最大内存之后，对应的淘汰策略是什么</li></ul><h2 id="redis几种内存淘汰策略"><a class="markdownIt-Anchor" href="#redis几种内存淘汰策略"></a> Redis几种内存淘汰策略</h2><h3 id="noeviction"><a class="markdownIt-Anchor" href="#noeviction"></a> noeviction</h3><p>不驱逐任何key，客户端返回异常</p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><h1 id="作为数据库"><a class="markdownIt-Anchor" href="#作为数据库"></a> 作为数据库</h1><h2 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h2><ul><li>数据很重要，不能丢失，一丢失就影响业务了</li><li>追求速度和持久性</li></ul><p>需要开启RDB或者AOF</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis的使用场景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis的使用场景&quot;&gt;&lt;/a&gt; Redis的使用场景&lt;/h1&gt;
&lt;p&gt;Redis有两种典型的使用场景，一个是把Redis作为缓存来使用，另一个是把Redis作为数据库</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="http://sandiegoe.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="缓存" scheme="http://sandiegoe.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Redis布隆过滤器</title>
    <link href="http://sandiegoe.github.io/2022/05/18/Redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://sandiegoe.github.io/2022/05/18/Redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2022-05-17T17:24:39.000Z</published>
    <updated>2022-05-22T15:00:51.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是布隆过滤器"><a class="markdownIt-Anchor" href="#什么是布隆过滤器"></a> 什么是布隆过滤器</h1><p>有时候我们可能希望快速判断某个key是否存在我们系统内，一种直观的想法是，拿着这个key到相应存储中查一遍，能查到，就说明存在，查不到则说明不存在。那么有没有一种更简单的方式来实现呢，因为有时候通过数据库查询的开销可能比较大。布隆过滤器就是一个比较好的选择，可以快速判断某个key是否存在，当然它并不是完全准确，有一定的误差。</p><h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2><h3 id="添加"><a class="markdownIt-Anchor" href="#添加"></a> 添加</h3><p>它会维护一个bitmap，当我们添加key的时候，会通过多个映射函数，计算出这个key在bitmap中的位置，并将相应位置的设置成1</p><h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3><p>当查询一个key的时候，同样会经过映射函数，计算该key在bitmap中的位置，当全部位置为1的时候，表示该key已经存在，当有一个位置为0时，表示该key不存在</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522215614.png" alt="" /></p><h2 id="布隆过滤器的几种结合方式"><a class="markdownIt-Anchor" href="#布隆过滤器的几种结合方式"></a> 布隆过滤器的几种结合方式</h2><h3 id="client端完成"><a class="markdownIt-Anchor" href="#client端完成"></a> client端完成</h3><p>在客户端维护bitmap，并实现布隆过滤器的算法</p><h3 id="client端算法redis保存bitmap"><a class="markdownIt-Anchor" href="#client端算法redis保存bitmap"></a> client端算法,Redis保存bitmap</h3><p>在redis中保存bitmap信息，在客户端来实现布隆过滤器算法</p><h3 id="redis-bloom模块"><a class="markdownIt-Anchor" href="#redis-bloom模块"></a> Redis Bloom模块</h3><p>通过Redis Bloom模块完成bitmap的存储和算法实现</p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><ul><li>不能删除key</li><li>不存在是精确的，存在是不精确的：通过布隆过滤器判断某个key存在时，不一定真的存在，有可能是对应的位被其他key置成了1，存在误差。这个误差和bitmap位数和放入key的数量相关</li><li>有哪些key，需要事先向bitmap中来标记</li><li>请求有可能会被误标记</li><li>概率解决问题，不可能100%阻挡</li><li>在一定概率上会大量减少因为穿透导致的放行</li><li>实现成本低</li></ul><h1 id="布隆过滤器怎么用"><a class="markdownIt-Anchor" href="#布隆过滤器怎么用"></a> 布隆过滤器怎么用</h1><h2 id="redisbloom布隆过滤器仓库地址"><a class="markdownIt-Anchor" href="#redisbloom布隆过滤器仓库地址"></a> RedisBloom布隆过滤器仓库地址</h2><p><a href="https://github.com/RedisBloom/RedisBloom">https://github.com/RedisBloom/RedisBloom</a></p><h2 id="安装布隆过滤器模块"><a class="markdownIt-Anchor" href="#安装布隆过滤器模块"></a> 安装布隆过滤器模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/RedisBloom/RedisBloom/archive/refs/tags/v2.0.3.tar.gz</span><br><span class="line">tar -zcvf v2.0.3.tar.gz</span><br><span class="line">cd RedisBloom-2.0.3</span><br><span class="line">make </span><br><span class="line">cp redisbloom.so /opt/redis7</span><br><span class="line">redis-server --loadmodule /opt/redis7/redisbloom.so</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522223403.png" alt="" /></p><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p><code>bf.add</code>：把某个key添加到布隆过滤器中<br /><code>bf.exists</code>：判断某个key是否存在</p><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><h2 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h2><p>缓存穿透指的是用户请求的数据即不在缓存，也不在数据库内，导致每次请求都需要查询数据库。</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522220946.png" alt="" /></p><h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h3><h4 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器"></a> 布隆过滤器</h4><p>通过布隆过滤器判断某个key是否存在，当布隆过滤器返回不存在时，直接返回，不再触发数据库查询。当然不能100%阻拦这种查询，还是有一定概率会发起数据库的查询，但是能够阻拦大部分请求。</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522221029.png" alt="" /></p><h4 id="空对象"><a class="markdownIt-Anchor" href="#空对象"></a> 空对象</h4><p>第一次访问不存在的时候，直接在缓存中放一个空内容。后续请求全部走Redis查询，返回空内容。</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522221009.png" alt="" /></p><h4 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220522221149.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是布隆过滤器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是布隆过滤器&quot;&gt;&lt;/a&gt; 什么是布隆过滤器&lt;/h1&gt;
&lt;p&gt;有时候我们可能希望快速判断某个key是否存在我们系统内，一种直观的想法是，拿着这个key到相应存储中查一遍，</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
    <category term="模块" scheme="http://sandiegoe.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis事物解析</title>
    <link href="http://sandiegoe.github.io/2022/05/18/Redis%E4%BA%8B%E7%89%A9%E8%A7%A3%E6%9E%90/"/>
    <id>http://sandiegoe.github.io/2022/05/18/Redis%E4%BA%8B%E7%89%A9%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-17T16:40:54.000Z</published>
    <updated>2022-05-22T13:36:29.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的事物是什么"><a class="markdownIt-Anchor" href="#redis的事物是什么"></a> Redis的事物是什么</h1><h2 id="什么是事物"><a class="markdownIt-Anchor" href="#什么是事物"></a> 什么是事物？</h2><p>事物中包含了一组操作，这些操作要么全部执行，要么全部不执行，实现这样的效果就称作为事物。</p><h2 id="redis和事物的关系"><a class="markdownIt-Anchor" href="#redis和事物的关系"></a> Redis和事物的关系</h2><p>Redis支持简单的事物，为什么说简单呢？因为Redis不支持事物的回滚。Redis的设计理念是为了追求性能，支持完成的事物，会增加系统的复杂度，对于性能也会有影响，因此在使用Redis事物的时候需要特别注意。</p><h2 id="事物中的操作记录在哪"><a class="markdownIt-Anchor" href="#事物中的操作记录在哪"></a> 事物中的操作记录在哪</h2><p>Redis是单线程的，不同客户端的事物彼此之间是相关隔离、相互独立的。当一个客户端开启了一个事物，客户端在exec之前提交的命令会放到一个缓冲区中，当客户端执行exec，Redis Server会执行事物中的所有操作。对于Redis来说，不同的事物都是排队在执行。</p><h2 id="多个客户端事物的执行顺序"><a class="markdownIt-Anchor" href="#多个客户端事物的执行顺序"></a> 多个客户端事物的执行顺序</h2><p>通过前面的描述，我们知道当客户端执行exec时，会触发Redis执行事物中的操作。因此Redis Server对于多个客户端提交的事物，会看哪个<code>事物先执行exec</code>，对于Redis来说时单线程来执行，肯定会有一个事物提交exec。当Redis Server接收到事物的exec命令时，就会执行该事物的所有操作，即使该事物的Multi可能比另外一个事物后提交。</p><h1 id="redis事物怎么用"><a class="markdownIt-Anchor" href="#redis事物怎么用"></a> Redis事物怎么用</h1><h2 id="help"><a class="markdownIt-Anchor" href="#help"></a> help</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @transactions</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a class="markdownIt-Anchor" href="#简单使用"></a> 简单使用</h2><p><code>multi</code>：表示开启一个事物，后续可以跟若干个操作，这些操作并不会立即执行<br /><code>exec</code>：表示提交一个事物，Redis将会执行事物的所有操作</p><h2 id="停止事物"><a class="markdownIt-Anchor" href="#停止事物"></a> 停止事物</h2><p><code>discard</code>：表示停止事物的执行</p><h2 id="乐观锁"><a class="markdownIt-Anchor" href="#乐观锁"></a> 乐观锁</h2><p>通过<code>watch</code>可以为实现实现一个类似乐观锁的效果，watch命令会观察某个key是否被其他客户端修改过，如果发生了修改，那么该事物不会执行，只有当该key没有被修改过，事物才能够执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set key java</span><br><span class="line">watch key </span><br><span class="line">multi</span><br><span class="line">set k1 hello</span><br><span class="line">get key</span><br><span class="line">exec</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis的事物是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis的事物是什么&quot;&gt;&lt;/a&gt; Redis的事物是什么&lt;/h1&gt;
&lt;h2 id=&quot;什么是事物&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="事物" scheme="http://sandiegoe.github.io/tags/%E4%BA%8B%E7%89%A9/"/>
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis发布订阅模型</title>
    <link href="http://sandiegoe.github.io/2022/05/18/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/"/>
    <id>http://sandiegoe.github.io/2022/05/18/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-05-17T16:40:46.000Z</published>
    <updated>2022-05-18T14:13:12.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是发布订阅模型"><a class="markdownIt-Anchor" href="#什么是发布订阅模型"></a> 什么是发布订阅模型</h1><p>Redis是支持发布订阅，发布的时候，先指定channel，然后发布消息；订阅的时候也需指定channel，当发布和订阅的是同一个channel时，发布者发送的消息会被所有已经订阅这个channel的客户端收到。<br /><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220518215502.png" alt="发布订阅模型" /></p><h1 id="redis发布订阅怎么用"><a class="markdownIt-Anchor" href="#redis发布订阅怎么用"></a> Redis发布订阅怎么用</h1><p><code>help @pubsub</code><br /><code>pubsub channels</code>：查询有哪些channel<br /><code>pubsub numsub</code>：查看channel的订阅数<br /><code>pubsub numpt</code>：查看模式的订阅数</p><h2 id="发布"><a class="markdownIt-Anchor" href="#发布"></a> 发布</h2><p><code>publish</code>：指定channel以及需要发送的消息</p><h2 id="订阅"><a class="markdownIt-Anchor" href="#订阅"></a> 订阅</h2><p><code>subscribe</code>：可以指定多个channel<br /><code>psubscribe</code>：支持按照模式订阅</p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220518220016.png" alt="示意图" /></p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><ul><li>订阅者无法收到历史消息，也就是只有监听channel之后发送的消息才能被接收到</li><li>Redis不会对消息进行持久化</li><li>和Kafka，RabbitMQ等消息队列相比，Redis的功能比较简单。如果使用场景对于消息的持久化、消息的回溯不关心，那么Redis是一个不错的选择。</li></ul><h1 id="具体案例"><a class="markdownIt-Anchor" href="#具体案例"></a> 具体案例</h1><h2 id="聊天室"><a class="markdownIt-Anchor" href="#聊天室"></a> 聊天室</h2><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220518221236.png" alt="" /></p><p><img src="https://raw.githubusercontent.com/sandiegoe/pic/main/img/20220518221306.png" alt="" /></p><h2 id="公告牌"><a class="markdownIt-Anchor" href="#公告牌"></a> 公告牌</h2><h2 id="服务之间的解耦合"><a class="markdownIt-Anchor" href="#服务之间的解耦合"></a> 服务之间的解耦合</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是发布订阅模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是发布订阅模型&quot;&gt;&lt;/a&gt; 什么是发布订阅模型&lt;/h1&gt;
&lt;p&gt;Redis是支持发布订阅，发布的时候，先指定channel，然后发布消息；订阅的时候也需指定chann</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
    <category term="pub/sub" scheme="http://sandiegoe.github.io/tags/pub-sub/"/>
    
  </entry>
  
  <entry>
    <title>Redis Pipeline解析</title>
    <link href="http://sandiegoe.github.io/2022/05/18/Redis%20Pipeline%E8%A7%A3%E6%9E%90/"/>
    <id>http://sandiegoe.github.io/2022/05/18/Redis%20Pipeline%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-17T16:40:36.000Z</published>
    <updated>2022-05-18T13:46:49.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pipeline是什么"><a class="markdownIt-Anchor" href="#pipeline是什么"></a> Pipeline是什么</h1><p>Pipeline也叫做流水线，它可以将一组redis命令进行封装，然后一次性的发送给Redis Server。假设我们需要访问10条redis key数据，一种常见的做法是每条key，客户端发送一条get请求取回数据，循环10次，取出全部的数据。如果有了Pipeline就可以将这10条get命令封装一个请求，一次性的发送到Redis Server，Redis Server接收到这个请求之后，收集10条命令的结果一次性的返回给客户端。</p><h1 id="为什么需要pipeline"><a class="markdownIt-Anchor" href="#为什么需要pipeline"></a> 为什么需要Pipeline</h1><h2 id="请求过程"><a class="markdownIt-Anchor" href="#请求过程"></a> 请求过程</h2><p>Redis客户端发起请求到Redis Server反悔结果，中间大概可以划分四个步骤：</p><ul><li>第一步：Redis客户端将请求发送Redis Server</li><li>第二步：Redis Server接收请求，命令排队</li><li>第三步：Redis Server执行命令</li><li>第四步：Redis Server将执行的结果返回给客户端<br />其中第一步和第四步都是需要有网络，称之为RTT(Round Trip Time， 往返时间)</li></ul><h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h2><p>当多个命令可以合并的时候，就可以不用每次都需要发送命令，返回结果。此时通过Pipeline将多个命令合并成一个请求，减少了网络交互次数，节省网络开销，提高了效率。特别是针对网络时延比较明显的大的，效果更显著</p><h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2><ul><li>初始化数据</li></ul><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><p>Pipeline中包含的命令也不能过大，增大了等待时间，也会造成一定的网络堵塞</p><h1 id="怎么使用"><a class="markdownIt-Anchor" href="#怎么使用"></a> 怎么使用</h1><h2 id="nc"><a class="markdownIt-Anchor" href="#nc"></a> nc</h2><p>nc，全称是netcat。当没有redis-cli客户端的时候，也可以通过nc向Redis Server发送命令。Redis Server默认端口是6379。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install nc</span><br><span class="line">nc localhost 6379</span><br><span class="line">keys *</span><br><span class="line">*0</span><br><span class="line">set a 1</span><br><span class="line">+OK</span><br><span class="line">get a </span><br><span class="line"><span class="meta">$</span><span class="bash">1</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> Pipeline</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;get a\nset a 20\nget a\nflushdb&quot; | redis-cli --pipe</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pipeline是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pipeline是什么&quot;&gt;&lt;/a&gt; Pipeline是什么&lt;/h1&gt;
&lt;p&gt;Pipeline也叫做流水线，它可以将一组redis命令进行封装，然后一次性的发送给Red</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
    <category term="Pipeline" scheme="http://sandiegoe.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-15T13:37:12.000Z</published>
    <updated>2022-05-17T14:55:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式</p><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h1><p>string表示的是value的类型，string有三类操作，针对字符串、针对数值和针对bitmap</p><blockquote><p>help @string</p></blockquote><p>sting =&gt; byte</p><p>string内部也包含三种：字符串、数值和bitmap</p><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><p><code>set</code><br /><code>get</code><br /><code>append</code><br /><code>setrange</code><br /><code>getrange</code><br /><code>strlen</code>：看的是有多少个字节，abcd长度为4，99999长度为5</p><h3 id="正反向索引"><a class="markdownIt-Anchor" href="#正反向索引"></a> 正反向索引：</h3><p>正向索引：0、1、2、3<br />反向索引：-1、-2、-3</p><h3 id="type命令"><a class="markdownIt-Anchor" href="#type命令"></a> type命令</h3><p><code>type k1</code>: 返回k1表示的value的类型</p><h3 id="object"><a class="markdownIt-Anchor" href="#object"></a> object</h3><p><code>object encoding k1</code>: 返回k1表示的value的编码</p><h3 id="二进制安全"><a class="markdownIt-Anchor" href="#二进制安全"></a> 二进制安全</h3><p>redis进程和外界交互的时候，使用的是字节流，底层存储也是二进制字节，通过encoding可以辅助判断，如果是int，可以直接incr，能够提高速度<br />中文一个字符utf8是三个字节，gbk是两个字节<br />hbase也是二进制安全的</p><h2 id="数值"><a class="markdownIt-Anchor" href="#数值"></a> 数值</h2><p><code>incr</code>：抢购、秒杀、商品详情，点赞，评论数、好友数，规避并发下对数据库的事物操作，计算向数据移动，完全由redis来替代<br /><code>incrby</code><br /><code>incrbyfloat</code><br /><code>decr</code><br /><code>decrby</code></p><h2 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> bitmap</h2><p><code>help setbit</code><br /><code>setbit</code><br /><code>bitcount</code>：返回start-end字节中统计1出现的次数<br /><code>bitpos</code>：返回第start-end字节的bit为指定值的位置<br /><code>bitop</code>：bitop operation destkey key [key …]，执行bit操作，operation与或非，destkey写入的目标key，key参与运算的key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setbit k1 1 1</span><br><span class="line">strlen k1 =&gt; 1</span><br><span class="line">getbit k1 =&gt; @</span><br><span class="line">setbit k1 9 1 </span><br><span class="line">strlen k1 =&gt; 2</span><br></pre></td></tr></table></figure><p>man ascii</p><h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3><p><code>用户系统</code>：统计用户的登录天数，且窗口随机</p><p><code>618活动，登录就送礼物</code>：仓库备货多少礼物，假设2亿用户<br />僵尸用户、冷热用户/忠诚用户<br />活跃用户统计，随机窗口<br />以天为key，每个key中的每个bit表示每个用户，需要做用户和bit的下标做映射</p><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h1><p>list是有序(说的是插入的顺序)，能够保存重复元素，为list类型的key会包含两个属性，head，tail用来指向链表的头节点和尾节点。</p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><p><code>help @list</code><br /><code>lpush</code>：往左边添加元素<br /><code>rpush</code>：往右边添加元素<br /><code>lpop</code>：弹出一个左边的元素<br /><code>rpop</code>：弹出一个右边的元素<br /><code>lrange</code>：看start-end的元素集合<br /><code>lindex</code>：查看某个索引位置的元素<br /><code>lset</code>：设置某个索引位置的元素<br /><code>lrem</code>：从list中移除count个元素，其值为value；count为正数，从左往右，为负数，从右往走<br /><code>linsert</code>：从某个位置插入一个元素<br /><code>llen</code><br /><code>blpop</code>：阻塞的左边弹<br /><code>ltrim</code>：移除start-end两端等数据</p><h2 id="使用场景-2"><a class="markdownIt-Anchor" href="#使用场景-2"></a> 使用场景</h2><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>可以用list来表示栈结构，使用同向命令</p><h3 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h3><p>用list来表示队列，使用反向命令</p><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>用list来表示数组，通过下标lindex, lset等</p><h3 id="阻塞-单播队列-fifo"><a class="markdownIt-Anchor" href="#阻塞-单播队列-fifo"></a> 阻塞 单播队列 FIFO</h3><p>使用blpop、lpush</p><h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> hash</h1><p>类似java中的HashMap，健值对形式</p><h2 id="常用命令-2"><a class="markdownIt-Anchor" href="#常用命令-2"></a> 常用命令</h2><p><code>hset</code><br /><code>hmset</code><br /><code>hget</code><br /><code>hmget</code><br /><code>hkeys</code><br /><code>kvals</code><br /><code>hgetall</code><br /><code>hincrbyfloat</code></p><h2 id="使用场景-3"><a class="markdownIt-Anchor" href="#使用场景-3"></a> 使用场景</h2><p>对field进行数值计算</p><h3 id="商品详情页"><a class="markdownIt-Anchor" href="#商品详情页"></a> 商品详情页</h3><h3 id="点赞-收藏-分享数"><a class="markdownIt-Anchor" href="#点赞-收藏-分享数"></a> 点赞、收藏、分享数</h3><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h1><p>是一个集合，集合内的元素不重复，无序。</p><h2 id="常用命令-3"><a class="markdownIt-Anchor" href="#常用命令-3"></a> 常用命令</h2><p><code>sadd</code><br /><code>smembers</code><br /><code>srem</code><br /><code>scard</code><br /><code>sinter</code>：取集合交集<br /><code>sinterstore</code>：交集的结果存储到某一个key里，没有IO<br /><code>sunion</code>：取集合到并集<br /><code>sunionstore</code><br /><code>sdiff</code>：返回集合的差集<br /><code>srandomemember</code>：随机返回一个集合中的元素，count为正数，取出一个去重的结果集（不能超过已有的结果集），count负数，可以取出一个带重复的结果集合，一定满足你要的数量，如果count为0，就不返回<br /><code>spop</code></p><h2 id="使用场景-4"><a class="markdownIt-Anchor" href="#使用场景-4"></a> 使用场景</h2><h3 id="抽奖一次抽多个"><a class="markdownIt-Anchor" href="#抽奖一次抽多个"></a> 抽奖(一次抽多个)</h3><p>使用srandomemember来实现，一个key中存放粉丝用户，+3 给你返回三个且去重，-3 给你反回允许重复</p><h3 id="抽奖一次抽一个不能重复抽"><a class="markdownIt-Anchor" href="#抽奖一次抽一个不能重复抽"></a> 抽奖(一次抽一个，不能重复抽)</h3><p>spop</p><h1 id="sorted-setzset"><a class="markdownIt-Anchor" href="#sorted-setzset"></a> sorted set(zset)</h1><p>去重且有序，按照score来进行排序。在内存里是按照链表来存储，默认左小右大的物理摆放顺序</p><h2 id="常用命令-4"><a class="markdownIt-Anchor" href="#常用命令-4"></a> 常用命令</h2><p><code>zadd</code><br /><code>zrange</code><br /><code>zrangebyscore</code><br /><code>zrevrange</code><br /><code>zscore</code><br /><code>zrank</code>：取出排名<br /><code>zincrby</code><br /><code>zunionstore</code></p><h2 id="排序怎么实现的"><a class="markdownIt-Anchor" href="#排序怎么实现的"></a> 排序怎么实现的</h2><p>底层是通过skiplist跳跃表(类平衡树)数据结构来实现的。每个元素插入的时候随机造层，越往上，节点数越少。针对增删改大量操作，平均值相对最优。</p><p><img src="https://pic4.zhimg.com/80/v2-1cc963c19eb34db31c47ef69a15f6863_1440w.jpg" alt="skiplist" /></p><h2 id="使用场景-5"><a class="markdownIt-Anchor" href="#使用场景-5"></a> 使用场景</h2><h3 id="榜单"><a class="markdownIt-Anchor" href="#榜单"></a> 榜单</h3><p>使用zrevrange命令取出前N</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式&lt;/p&gt;
&lt;h1 id=&quot;string&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="缓存" scheme="http://sandiegoe.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="http://sandiegoe.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-15T10:21:20.000Z</published>
    <updated>2022-05-16T06:19:22.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis相关的原理"><a class="markdownIt-Anchor" href="#redis相关的原理"></a> Redis相关的原理</h1><p>一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线程，单实例。客户端可能会有很多个，可能以socket fd形式，连到系统kernel上，redis通过epoll来取数据，单线程，顺序来读取。</p><blockquote><p>顺序性：每个连接内的命令是顺序的 =》衍生kafka topic 分区消息顺序性</p></blockquote><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><p>通过 <code>redis-cli</code> 命令启动客户端</p><h3 id="切换库"><a class="markdownIt-Anchor" href="#切换库"></a> 切换库</h3><p>redis默认是有16个库，0～15</p><blockquote><p>redis-cli -db<br />select db<br />不同db之间数据是隔离的</p></blockquote><h3 id="help"><a class="markdownIt-Anchor" href="#help"></a> help</h3><p>通用：help @generic</p><p>value: help @sting @list @hash</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h2><p>每个连接对应一个线程，Socket在这个时期是blocking的。</p><h2 id="同步非阻塞-nio"><a class="markdownIt-Anchor" href="#同步非阻塞-nio"></a> 同步非阻塞 NIO</h2><p>对应一个线程，不用阻塞，不用很多的线程。会轮询调用kernel, 检查fd有没有数据。比如有1000个fd，代表用户进程轮询调用1000次kernel。一个线程可以hold住1000个连接，避免每个连接对应一个线程，增加系统成本。在这个期间，会涉及用户和内核空间转换，上下文切换等等，有系统开销，成本比较大。</p><blockquote><p>轮询是发生在用户空间。<br />线程多了，cpu调度成本高，频繁做线程切换，内存成本高，一个线程占用1MB内存。</p></blockquote><h2 id="多路复用-nio"><a class="markdownIt-Anchor" href="#多路复用-nio"></a> 多路复用 NIO</h2><p>调用系统内核的select，将上面的1000个文件描述符全部传进来。只会调用一次，在内核态等待，再返回fd，然后用户空间再通过read调用挨个访问fd。在这个过程中还是会涉及到fd相关的数据拷贝来拷贝去。</p><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><h3 id="epoll-create"><a class="markdownIt-Anchor" href="#epoll-create"></a> epoll create</h3><p>create epfd</p><h3 id="ctl"><a class="markdownIt-Anchor" href="#ctl"></a> ctl</h3><p>ctl add delete socket fd</p><h3 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h3><p>等待事件，数据准备好了，放到链表，就可以返回了。</p><h3 id="mmap共享空间"><a class="markdownIt-Anchor" href="#mmap共享空间"></a> MMAP共享空间</h3><p>划分出来一个共享空间，内核和用户都可以直接访问。上面的1000个文件描述符直接写入到共享空间，内核直接通过地址访问这个共享空间，避免了fd相关数据的拷贝。</p><blockquote><p>使用红黑树来表示文件描述符<br />使用链表来表示已经读取好的文件描述符</p></blockquote><h2 id="零拷贝"><a class="markdownIt-Anchor" href="#零拷贝"></a> 零拷贝</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis相关的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis相关的原理&quot;&gt;&lt;/a&gt; Redis相关的原理&lt;/h1&gt;
&lt;p&gt;一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-15T06:24:35.000Z</published>
    <updated>2022-05-15T07:33:27.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis常识"><a class="markdownIt-Anchor" href="#redis常识"></a> Redis常识</h1><h2 id="为什么需要redis"><a class="markdownIt-Anchor" href="#为什么需要redis"></a> 为什么需要Redis？</h2><p>在软件架构里，数据通常存储在数据库里。数据库存储在磁盘文件里，会受到磁盘IO的影响，存在性能瓶颈。当访问量特别大的时候，频繁访问数据库，磁盘IO比较高，查询性能比较慢。这时候可以适当加上缓存，Redis就是个不错的选择。可以将经常查询的数据放在Redis里，借助Redis数据放在内存，提供的高效的查询能力助力业务。</p><h2 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h2><p>引入Redis之后，需要面对一个问题，如何保证数据库和缓存数据的一致性？</p><h2 id="和io相关的知识"><a class="markdownIt-Anchor" href="#和io相关的知识"></a> 和IO相关的知识</h2><h3 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h3><p>说的磁盘会有两个和磁盘相关的指标，一个是寻址，一个是带宽</p><ul><li>寻址：一般是在毫秒级别</li><li>带宽：单位时间内流过的数据量，一般是G或者MB</li></ul><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p>内存同样也会有这两个指标</p><ul><li>寻址：一般是在纳秒级别</li><li>带宽：很大</li></ul><p>在寻址方面内存会比磁盘快10W倍。</p><h3 id="io-buffer"><a class="markdownIt-Anchor" href="#io-buffer"></a> I/O buffer</h3><p>磁盘会有磁道和扇区，一个扇区512字节。如果这个容量太小，扇区数就会增加，索引就会增大，会增加管理的成本。<br />操作系统读取写入数据一般是按照4K个字节为单位来进行存取，即使只需要少量几个字节的信息，也会一次性的读取整个4K字节，提高访问速度。我们在进行磁盘格式化的时候，需要做分区对齐，一般也是4K。</p><blockquote><p>随着磁盘中文件越来越大，访问速度会变慢？这是因为此时磁盘IO成为了瓶颈。</p></blockquote><h2 id="和数据库相关的知识"><a class="markdownIt-Anchor" href="#和数据库相关的知识"></a> 和数据库相关的知识</h2><h3 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h3><p>当我们往数据库里放数据，首先需要为其创建一张表，定义好schema，表中包含哪些字段，类型是什么。存储的时候倾向按行来存储，将一条数据包含的所有内容，按照行的形式存到文件里。具体的存储格式和数据库存储引擎相关。</p><h3 id="数据查询"><a class="markdownIt-Anchor" href="#数据查询"></a> 数据查询</h3><p>当查询没有命中索引，会进行全表扫描，磁盘IO是比较大的。当命中索引时，可以通过索引快速查询出需要的数据，减少不必要的IO。MySQL数据库Innodb存储引擎，索引是通过B+树来实现的，每个节点可以有多个分叉，只有叶子结点存储数据，非叶子结点不存储数据，实现了用很少的层数来索引大量的数据。三层B+树，就可以来表示千万级别的数据量。</p><h3 id="表很大性能下降"><a class="markdownIt-Anchor" href="#表很大性能下降"></a> 表很大，性能下降？</h3><h4 id="增删改"><a class="markdownIt-Anchor" href="#增删改"></a> 增删改</h4><p>有索引，增删改的成本会变高，因为涉及到维护索引。</p><h4 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h4><p>单个或者少量的查询还是很快，并发大的时候会受到磁盘带宽的影响，速度会变慢（数据量大，即使通过索引命中的数据可能也比较多）。</p><h1 id="redis安装"><a class="markdownIt-Anchor" href="#redis安装"></a> Redis安装</h1><h2 id="redis官网"><a class="markdownIt-Anchor" href="#redis官网"></a> Redis官网</h2><p><a href="https://redis.io/">redis.io</a></p><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.下载安装包</span> </span><br><span class="line">wget https://github.com/redis/redis/archive/7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.解压缩安装包</span> </span><br><span class="line">tar -zxvf redis-7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.查看README.md</span></span><br><span class="line">cat README.md</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.编译安装</span></span><br><span class="line">yum install gcc</span><br><span class="line">make </span><br><span class="line">make install PREFIX=/opt/redis7</span><br><span class="line">make test </span><br><span class="line">make distclean</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.配置环境变量</span></span><br><span class="line">vi /etc/prifile</span><br><span class="line">export REDIS_HOME=/opt/redis7</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.配置系统服务</span></span><br><span class="line">sh utils/install_server.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.启动停止redis</span></span><br><span class="line">service redis_6379 start/stop/restart/status</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_44187615/article/details/111079601">This systems seems to use systemd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis常识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis常识&quot;&gt;&lt;/a&gt; Redis常识&lt;/h1&gt;
&lt;h2 id=&quot;为什么需要redis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么需</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态年龄</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/</id>
    <published>2022-01-28T07:32:12.000Z</published>
    <updated>2022-01-28T07:32:12.067Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>标量替换</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/</id>
    <published>2022-01-28T07:31:19.000Z</published>
    <updated>2022-01-28T07:31:19.565Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
