<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arexstorm个人工作站</title>
  
  
  <link href="http://sandiegoe.github.io/atom.xml" rel="self"/>
  
  <link href="http://sandiegoe.github.io/"/>
  <updated>2022-05-15T14:20:03.209Z</updated>
  <id>http://sandiegoe.github.io/</id>
  
  <author>
    <name>Arexstorm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据类型</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-15T13:37:12.000Z</published>
    <updated>2022-05-15T14:20:03.209Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式</p><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h1><blockquote><p>help @string</p></blockquote><p>sting =&gt; byte</p><p>string内部也包含三种：字符串、数值和bitmap</p><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><p><code>set</code><br /><code>get</code><br /><code>append</code><br /><code>setrange</code><br /><code>getrange</code><br /><code>strlen</code></p><h3 id="正反向索引"><a class="markdownIt-Anchor" href="#正反向索引"></a> 正反向索引：</h3><p>正向索引：0、1、2、3<br />反向索引：-1、-2、-3</p><h3 id="type命令"><a class="markdownIt-Anchor" href="#type命令"></a> type命令</h3><p><code>type k1</code>: 返回k1表示的value的类型</p><h3 id="object"><a class="markdownIt-Anchor" href="#object"></a> object</h3><p><code>object encoding k1</code>: 返回k1表示的value的编码</p><h2 id="数值"><a class="markdownIt-Anchor" href="#数值"></a> 数值</h2><p><code>incr</code>：抢购、秒杀、商品详情，点赞，评论数、好友数，规避并发下对数据库的事物操作，计算向数据移动，完全由redis来替代<br /><code>incrby</code><br /><code>incrbyfloat</code><br /><code>decr</code><br /><code>decrby</code></p><h2 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> bitmap</h2><p><code>setbit</code><br /><code>bitcount</code><br /><code>bitpos</code><br /><code>bitpop</code></p><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> list</h1><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h1><h1 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> zset</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是一种K、V型数据库，针对V Redis内置了多种数据类型，常见的如string、list、set、zset等。K上会包含一个type，用来表示V的类型，还会包含encoding，表示V的编码格式&lt;/p&gt;
&lt;h1 id=&quot;string&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis原理</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-15T10:21:20.000Z</published>
    <updated>2022-05-15T12:07:49.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis相关的原理"><a class="markdownIt-Anchor" href="#redis相关的原理"></a> Redis相关的原理</h1><p>一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线程，单实例。客户端可能会有很多个，可能以socket fd形式，连到系统kernel上，redis通过epoll来取数据，单线程，顺序来读取。</p><blockquote><p>顺序性：每个连接内的命令是顺序的 =》衍生kafka topic 分区消息顺序性</p></blockquote><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><p>通过 <code>redis-cli</code> 命令启动客户端</p><h3 id="切换库"><a class="markdownIt-Anchor" href="#切换库"></a> 切换库</h3><p>redis默认是有16个库，0～15</p><blockquote><p>redis-cli -db<br />select db<br />不同db之间数据是隔离的</p></blockquote><h3 id="help"><a class="markdownIt-Anchor" href="#help"></a> help</h3><p>通用：help @generic</p><p>value: help @sting @list @hash</p><h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h2><p>每个连接对应一个线程，Socket在这个时期是blocking的。</p><h2 id="同步非阻塞-nio"><a class="markdownIt-Anchor" href="#同步非阻塞-nio"></a> 同步非阻塞 NIO</h2><p>对应一个线程，不用阻塞，不用很多的线程。会轮询调用kernel, 检查fd有没有数据。比如有1000个fd，代表用户进程轮询调用1000次kernel。一个线程可以hold住1000个连接，避免每个连接对应一个线程，增加系统成本。在这个期间，会涉及用户和内核空间转换，上下文切换等等，有系统开销，成本比较大。</p><blockquote><p>轮询是发生在用户空间。<br />线程多了，cpu调度成本高，频繁做线程切换，内存成本高，一个线程占用1MB内存。</p></blockquote><h2 id="多路复用-nio"><a class="markdownIt-Anchor" href="#多路复用-nio"></a> 多路复用 NIO</h2><p>调用系统内核的select，将上面的1000个文件描述符全部传进来。只会调用一次，在内核态等待，再返回fd，然后用户空间再通过read调用挨个访问fd。在这个过程中还是会涉及到fd相关的数据拷贝来拷贝去。</p><h2 id="epoll"><a class="markdownIt-Anchor" href="#epoll"></a> epoll</h2><h3 id="epoll-create"><a class="markdownIt-Anchor" href="#epoll-create"></a> epoll create</h3><p>create epfd</p><h3 id="ctl"><a class="markdownIt-Anchor" href="#ctl"></a> ctl</h3><p>ctl add delete socket fd</p><h3 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h3><p>等待事件，数据准备好了，放到链表，就可以返回了。</p><h3 id="mmap共享空间"><a class="markdownIt-Anchor" href="#mmap共享空间"></a> MMAP共享空间</h3><p>划分出来一个共享空间，内核和用户都可以直接访问。上面的1000个文件描述符直接写入到共享空间，内核直接通过地址访问这个共享空间，避免了fd相关数据的拷贝。</p><blockquote><p>使用红黑树来表示文件描述符<br />使用链表来表示已经读取好的文件描述符</p></blockquote><h2 id="零拷贝"><a class="markdownIt-Anchor" href="#零拷贝"></a> 零拷贝</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis相关的原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis相关的原理&quot;&gt;&lt;/a&gt; Redis相关的原理&lt;/h1&gt;
&lt;p&gt;一台Linux机器上面可以跑多个Redis进程，多个实例。针对单个Redis来说，是单进程，单线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://sandiegoe.github.io/2022/05/15/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-15T06:24:35.000Z</published>
    <updated>2022-05-15T07:33:27.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis常识"><a class="markdownIt-Anchor" href="#redis常识"></a> Redis常识</h1><h2 id="为什么需要redis"><a class="markdownIt-Anchor" href="#为什么需要redis"></a> 为什么需要Redis？</h2><p>在软件架构里，数据通常存储在数据库里。数据库存储在磁盘文件里，会受到磁盘IO的影响，存在性能瓶颈。当访问量特别大的时候，频繁访问数据库，磁盘IO比较高，查询性能比较慢。这时候可以适当加上缓存，Redis就是个不错的选择。可以将经常查询的数据放在Redis里，借助Redis数据放在内存，提供的高效的查询能力助力业务。</p><h2 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h2><p>引入Redis之后，需要面对一个问题，如何保证数据库和缓存数据的一致性？</p><h2 id="和io相关的知识"><a class="markdownIt-Anchor" href="#和io相关的知识"></a> 和IO相关的知识</h2><h3 id="磁盘"><a class="markdownIt-Anchor" href="#磁盘"></a> 磁盘</h3><p>说的磁盘会有两个和磁盘相关的指标，一个是寻址，一个是带宽</p><ul><li>寻址：一般是在毫秒级别</li><li>带宽：单位时间内流过的数据量，一般是G或者MB</li></ul><h3 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h3><p>内存同样也会有这两个指标</p><ul><li>寻址：一般是在纳秒级别</li><li>带宽：很大</li></ul><p>在寻址方面内存会比磁盘快10W倍。</p><h3 id="io-buffer"><a class="markdownIt-Anchor" href="#io-buffer"></a> I/O buffer</h3><p>磁盘会有磁道和扇区，一个扇区512字节。如果这个容量太小，扇区数就会增加，索引就会增大，会增加管理的成本。<br />操作系统读取写入数据一般是按照4K个字节为单位来进行存取，即使只需要少量几个字节的信息，也会一次性的读取整个4K字节，提高访问速度。我们在进行磁盘格式化的时候，需要做分区对齐，一般也是4K。</p><blockquote><p>随着磁盘中文件越来越大，访问速度会变慢？这是因为此时磁盘IO成为了瓶颈。</p></blockquote><h2 id="和数据库相关的知识"><a class="markdownIt-Anchor" href="#和数据库相关的知识"></a> 和数据库相关的知识</h2><h3 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h3><p>当我们往数据库里放数据，首先需要为其创建一张表，定义好schema，表中包含哪些字段，类型是什么。存储的时候倾向按行来存储，将一条数据包含的所有内容，按照行的形式存到文件里。具体的存储格式和数据库存储引擎相关。</p><h3 id="数据查询"><a class="markdownIt-Anchor" href="#数据查询"></a> 数据查询</h3><p>当查询没有命中索引，会进行全表扫描，磁盘IO是比较大的。当命中索引时，可以通过索引快速查询出需要的数据，减少不必要的IO。MySQL数据库Innodb存储引擎，索引是通过B+树来实现的，每个节点可以有多个分叉，只有叶子结点存储数据，非叶子结点不存储数据，实现了用很少的层数来索引大量的数据。三层B+树，就可以来表示千万级别的数据量。</p><h3 id="表很大性能下降"><a class="markdownIt-Anchor" href="#表很大性能下降"></a> 表很大，性能下降？</h3><h4 id="增删改"><a class="markdownIt-Anchor" href="#增删改"></a> 增删改</h4><p>有索引，增删改的成本会变高，因为涉及到维护索引。</p><h4 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h4><p>单个或者少量的查询还是很快，并发大的时候会受到磁盘带宽的影响，速度会变慢（数据量大，即使通过索引命中的数据可能也比较多）。</p><h1 id="redis安装"><a class="markdownIt-Anchor" href="#redis安装"></a> Redis安装</h1><h2 id="redis官网"><a class="markdownIt-Anchor" href="#redis官网"></a> Redis官网</h2><p><a href="https://redis.io/">redis.io</a></p><h2 id="安装步骤"><a class="markdownIt-Anchor" href="#安装步骤"></a> 安装步骤</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.下载安装包</span> </span><br><span class="line">wget https://github.com/redis/redis/archive/7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.解压缩安装包</span> </span><br><span class="line">tar -zxvf redis-7.0.0.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.查看README.md</span></span><br><span class="line">cat README.md</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.编译安装</span></span><br><span class="line">yum install gcc</span><br><span class="line">make </span><br><span class="line">make install PREFIX=/opt/redis7</span><br><span class="line">make test </span><br><span class="line">make distclean</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.配置环境变量</span></span><br><span class="line">vi /etc/prifile</span><br><span class="line">export REDIS_HOME=/opt/redis7</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.配置系统服务</span></span><br><span class="line">sh utils/install_server.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.启动停止redis</span></span><br><span class="line">service redis_6379 start/stop/restart/status</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_44187615/article/details/111079601">This systems seems to use systemd</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis常识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis常识&quot;&gt;&lt;/a&gt; Redis常识&lt;/h1&gt;
&lt;h2 id=&quot;为什么需要redis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么需</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动态年龄</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84/</id>
    <published>2022-01-28T07:32:12.000Z</published>
    <updated>2022-01-28T07:32:12.067Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>标量替换</title>
    <link href="http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/"/>
    <id>http://sandiegoe.github.io/2022/01/28/%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2/</id>
    <published>2022-01-28T07:31:19.000Z</published>
    <updated>2022-01-28T07:31:19.565Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
